// Welcome file, TODO: welcome message.

typedef A = int
typedef X = exists A.forall B.( a#A + b#B )
typedef F = !int -o boolean -o string
typedef C[A,B] = int :: A :: B

typedef Y[x] = boolean{int/x}

typedef Sum[q,l] = tag#(ref q) + teg#(ref l)

typedef  Node[p] = exists q.( (rw p Node#![element: int, next: ref q]) * Head[q] )
typedef Close[p] = rw p Close#![]
typedef Empty[p] = rw p Empty#![]

typedef Tail[p] = Empty[p] => ( Close[p] (+) Node[p] )
typedef Head[p] = ( Node[p] => Node[p] ; Node[p] ) (+)
				( Close[p] => Close[p] ; Close[p] ) (+)
				( Empty[p] => Empty[p] ; Head[p] ) // retries


// subtyping
    subtype [a:int,b:int] <: [a:int]
<B> subtype [a:int,b:B] <: [a:int]
    subtype int <: !int
not subtype int <: boolean

// equality
    equals int == int
    equals forall X.(X{int/X}) == forall Y.int
not equals int == boolean
not equals int == !int
not equals forall X.forall Y.[X,Y] == forall X.forall Y.[Y,X]

	equals forall X.(forall X.forall X.X){int/X} == forall X.forall X.forall X.X
	equals exists X.(forall X.exists X.X){int/X} == exists X.forall X.exists X.X

not equals forall X<:int.forall X<:boolean.forall X<:string.X == forall X<:string.forall X<:boolean.forall X<:int.X

// substitution
<X> equals X{A/X} == A

// sharing
	 share none as none || none
<l> share Empty[l] as Head[l] || Tail[l]
