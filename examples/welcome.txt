// Old Re-Splitting Examples:


//	rec X.( F => F ; X & F => R ; R => R ; R )
//	>> F => R
//	|| ( rec X.( F => F ; X (+) R => R ; R )
//		>> rec X.( F => F ; X (+) R => D )
//		|| rec X.( F => F ; X (+) rec Y.( R => R ; Y (+) D => D; D ) ) )
typedef R[p] = rw p R#[]
typedef F[p] = rw p F#int
typedef D[p] = rw p D#boolean

typedef P_0[p] = ( F[p] => F[p] ; P_0[p] ) & ( F[p] => R[p] ; R[p] => R[p] ; R[p] )
typedef P_1[p] = F[p] => R[p]
typedef P_2[p] = ( F[p] => F[p] ; P_2[p] ) (+) ( R[p] => R[p] ; R[p] )

<t> share P_0[t] as P_1[t] || P_2[t]

typedef Q_0[p] = ( F[p] => F[p] ; Q_0[p] ) (+) ( R[p] => R[p] ; R[p] => D[p] )
typedef Q_1[p] = ( F[p] => F[p] ; Q_1[p] ) (+) Q_2[p]
typedef Q_2[p] = ( R[p] => R[p] ; Q_2[p] ) (+) ( D[p] => D[p] ; D[p] )

<t> share P_2[t] as Q_0[t] || Q_1[t]

// Only one recovers ownership
	//	H => F ; F => F ; F
	// >> H => F ; none (+) F => F ; F
	// || H => F ; none (+) F => F ; F
typedef FF[p] = rw p F#[]
typedef HH[p] = rw p H#int

<t> share (HH[t] => FF[t] ; FF[t] => FF[t] ; FF[t] ) as
	  ( HH[t] => FF[t] ; none ) (+) ( FF[t] => FF[t] ; FF[t] )
	||( HH[t] => FF[t] ; none ) (+) ( FF[t] => FF[t] ; FF[t] )

// Simple Monotonic 2-State Counter
	//	rec X.( N => P ; rec Y.( P => N ; X & N => P ; Y ) )
	//	>>
	//	rec X.( N => P ; P => N ; X )
	//	||	rec X.( N => P ; X )
typedef NN[p] = rw p Z#[]+NZ#int
typedef PP[p] = rw p NZ#int

typedef IncOnly[p] =  NN[p] => PP[p] ; IncOnly[p]
typedef Any[p] = NN[p] => PP[p]; PP[p] => NN[p] ; Any[p]

typedef M0[p] = NN[p] => PP[p] ; M1[p]
typedef M1[p] = ( PP[p] => NN[p] ; M0[p] ) & ( NN[p] => PP[p] ; M1[p] )

<t> share NN[t] as IncOnly[t] || Any[t]
<t> share M0[t] as IncOnly[t] || Any[t]

<t> share IncOnly[t] as IncOnly[t] || IncOnly[t]
<t> not share Any[t] as Any[t] || Any[t]

// Pipe
	//	    rec X.( E => E ; X & E => N (+) C ; ( N => N ; N ) (+) ( C => C ; C ) )
	//	>>	E => N (+) C ; none
	//	||	rec X.( E => E ; X (+) ( N => N ; N ) (+) ( C => C ; C ) )
typedef N[p] = exists q.( (rw p Node#![element: int, next: ref q]) * H[q] )
typedef C[p] = rw p Close#![]
typedef E[p] = rw p Empty#![]

typedef T[p] = E[p] => ( N[p] (+) C[p] ) ; none
typedef H[p] = ( E[p] => E[p] ; H[p] ) (+) ( N[p] => N[p] ; N[p] ) (+) ( C[p] => C[p] ; C[p] )

typedef O[p] = ( E[p] => E[p] ; O[p] ) & ( E[p] => N[p] (+) C[p] ; ( N[p] => N[p] ; N[p] ) (+) ( C[p] => C[p] ; C[p] ) )

<t> share O[t] as T[t] || H[t]






// Welcome file, TODO: welcome message.

typedef A = int
typedef X = exists A.forall B.( a#A + b#B )
typedef Fun = !int -o boolean -o string
typedef Cap[A,B] = int :: A :: B

typedef Y[x] = boolean{int/x}

typedef Sum[q,l] = tag#(ref q) + teg#(ref l)

// subtyping
    subtype [a:int,b:int] <: [a:int]
<B> subtype [a:int,b:B] <: [a:int]
    subtype int <: !int
not subtype int <: boolean

 	subtype int <: exists q.int
	subtype [] <: exists X.[]
	subtype [int,boolean] <: exists X.[X,boolean]

<q> subtype rw q int <: exists w.rw w int
<q> subtype rw q string <: exists w.rw q string

<q> subtype forall w.rw w int <: rw q int
<q> subtype forall w.rw w string <: rw q string
<q> subtype forall w.rw q string <: rw q string

	 not subtype [int,boolean] <: exists X.[X,X]
<q> not subtype rw q int <: exists w.rw w boolean

// equality
    equals int == int
    equals forall X.(X{int/X}) == forall Y.int
not equals int == boolean
not equals int == !int
not equals forall X.forall Y.[X,Y] == forall X.forall Y.[Y,X]

	equals forall X.(forall X.forall X.X){int/X} == forall X.forall X.forall X.X
	equals exists X.(forall X.exists X.X){int/X} == exists X.forall X.exists X.X

not equals forall X<:int.forall X<:boolean.forall X<:string.X == forall X<:string.forall X<:boolean.forall X<:int.X

// substitution
<X> equals X{A/X} == A

// Sharing - Pipe Example.
typedef  Node[p] = exists q.( (rw p Node#![element: int, next: ref q]) * Head[q] )
typedef Close[p] = rw p Close#![]
typedef Empty[p] = rw p Empty#![]

typedef Tail[p] = Empty[p] => ( Close[p] (+) Node[p] )
typedef Head[p] = ( Node[p] => Node[p] ; Node[p] ) (+)
				( Close[p] => Close[p] ; Close[p] ) (+)
				( Empty[p] => Empty[p] ; Head[p] ) // retries

	 share none as none || none
<l> share Empty[l] as Head[l] || Tail[l]
