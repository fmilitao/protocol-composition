/* === CONFORMANCE TESTS === */

// Pipe
typedef Head[p] =	( rw p !(Empty#[]) => rw p !(Empty#[]) ; Head[p] ) (+)
					( rw p !(Closed#[]) => none ) (+) 
					( rw p (Node#[int,exists q.(!ref q :: Head[q] )]) => none )

typedef Tail[p] =  (rw p !Empty#[]) => ( (rw p !Closed#[]) (+) (rw p Node#[int,exists q.(!ref q :: Head[q])]) )

// Iteratively Sharing
typedef F[f,c] = (rw f Free#[]) * (rw c [])
typedef R[f,c] = (rw f Raw#[]) * (rw c int)
typedef D[f,c] = (rw f Done#[]) * (rw c boolean)

typedef Receiver   [f,c] = F[f,c] => R[f,c]
typedef Compressor [f,c] = ( F[f,c] => F[f,c] ; Compressor[f,c] ) (+) 
									( R[f,c] => D[f,c] )

typedef Storer  [f,c] = ( F[f,c] => F[f,c] ; Storer[f,c] ) (+) Storer_[f,c] 
typedef Storer_ [f,c] = ( R[f,c] => R[f,c] ; Storer_[f,c] ) (+) ( D[f,c] => none )

typedef TMP  [f,c] = ( F[f,c] => F[f,c] ; TMP[f,c] ) (+) TMP_[f,c]
typedef TMP_ [f,c] = ( R[f,c] => R[f,c] ; TMP_[f,c] ) & ( R[f,c] => D[f,c] ; D[f,c] => none )

//
// Tests
//

typedef Held[t] = rw t Held#[]
typedef Free[t] = rw t Free#int

typedef A[p] = ( Held[p] => Held[p] ; A[p] ) & ( Held[p] => Held[p] ; A[p] )
typedef B[p] = ( Held[p] => Held[p] ; B[p] ) & ( Held[p] => Free[p] ; Free[p] )

typedef P[l] = ( Held[l] => Held[l] ; P[l] ) & ( Held[l] => Free[l] ; Free[l] )
typedef P0[l] = ( Held[l] => Held[l] ; P0[l] ) (+) ( Free[l] => Free[l] ; Free[l] )
typedef P1[l] = ( Held[l] => Free[l] )

// typedef P3[l] = ( Held[l] => Held[l] ; P3[l] ) (+) ( Free[l] => Held[l] ; Held[l] => none )
// typedef P4[l] = ( Held[l] => Held[l] ; P4[l] ) & ( Held[l] => Free[l] ; Free[l] => Held[l] ; Held[l] => none )

// end of typedefs.

// <l> share (rw l !Empty#[]) as Head[l] || Tail[l]

// <f><c> share F[f,c] as Receiver[f,c] || TMP[f,c]
// <f><c> share TMP[f,c] as Storer[f,c] || Compressor[f,c]


/*
share none as none || none

<t> share Held[t] as B[t] || none

<t> share Held[t] as A[t] || A[t]
*/

<t> share P[t] as P0[t] || P1[t]

// <t> share P4[t] as P3[t] || P1[t]
