Protocol Conformance Checker
============================

Grammar is limited to only check 'equals', 'subtype' and 'share' (and substitution).
Instead of recursion, we have 'typedef' for clarity.

TODO/PROBLEMS/BUGS:
===================

* missing failure tests on conformance on 'test2.txt'

* Old (Re-Splitting) Examples:

#1
	rec X.( E => E ; X & E => N (+) C ; ( N => N ; N ) (+) ( C => C ; C ) )
>>
	E => N (+) C ; none
||	rec X.( E => E ; X (+) ( N => N ; N ) (+) ( C => C ; C ) )

#2
	NE (+) E => NE ; rec X.( NE => NE ; X )

#3
	rec X.( N => P ; rec Y.( P => N ; X & N => P ; Y ) )
>>
	rec X.( N => P ; P => N ; X )
||	rec X.( N => P ; X )

#4
	rec X.( F => F ; X & F => R ; R => R ; R )
>>
	F => R
||	rec X.( F => F ; X (+) R => R ; R )
>>
	rec X.( F => F ; X (+) R => D )
	rec X.( F => F ; X (+) rec Y.( R => R ; Y (+) D => D; D ) )

#5
	H => F ; F => F ; F
>>
	H => F ; none (+) F => F ; F
||	H => F ; none (+) F => F ; F



* Check if case is really undecidable. Add check to forbid undecidable case, if that is the case. It may be possible that the example is ill-constructed and therefore fails to catch this error. Thus, you may need to build a better counter-example that exercises the problem.
	The case is undecidable at least on protocol conformance. If we have:
	P[A] = rw p A => forall X <: A.( rw p X ; P[X] )
	then the typing environment will grow without end, making the use of subsumption on conformance impossible and therefore
we will never be able to close the proof.
	**CAREFUL** how does this mix with the examples with refinements?

	The simple solution if to enforce that:
	EMPTY |- A type 	Gamma, X <: A |- B type
	-------------------------------------------
		Gamma |- forall X <: A.B

	(and same for exists)

	Likewise, our examples need something of the kind:

		( X <: A ) in Gamma
	 Gamma |- A <: B
	------------------- (i.e. transitivity on bounds???)
	 Gamma |- X <: B

	but this may be undecidable is we do not constrain the type in the bounded quantification type.

* Note: configuration should not be undecidable since we are just narrowing it down. If it worked for a larget set of types then it should also work for a narrower set, right?

* undecidable exists X <: A || forall Y <: B, iff A <: B, we must restrict bound to be EMPTY |- A type, no variables.

* FIX on keyF that creates key to table cycles in the types, needs to consider environment due to bouned quantification.

* Protocol Well-Formedness:
	- isProtocol( type ) true if type contains a protocol, false if non-protocol type
	- check that each RelyType and GuaranteeType refer the same set of locations (location set invariant)
	- (+) ensure distinctness in alternative triggers (distinct alternative)
	- abstractions:
		+ same level abstraction must only refer X <: P where isProtocol(P)
		+ or X must also be at the guarantee type unabstracted?

* consider "superficial equality" (i.e. no need to unfold):
	case types.DefinitionType:
		if( t1.definition() !== t2.definition() )
			return false;
		
		var t1s = t1.args();
		var t2s = t2.args();
		if( t1s.length !== t2s.length )
			return false;
		for( var i=0;i<t1s.length;++i )
			if( !equalsAux( t1s[i], t2s[i], trail ) )
				return false;
		return true;
	}


===================

- define error constants/enum instead of having constants spread out through the code.

- use 'const' keyword for constants. Note that some browsers may not support this. However, our target is Google Chrome which does support 'const'. See: http://kangax.github.io/compat-table/es6/

- JS tips: http://bonsaiden.github.io/JavaScript-Garden/

- cool transitions: https://github.com/IanLunn/Hover

Extra Credits:
==============

- Types and Programming Languages, Chapter 6 (for De Bruijn stuff).
- Subtyping Recursive Types, for recursion checks.

