Protocol Conformance Checker
============================

Grammar is limited to only check 'equals', 'subtype' and 'share' (and substitution).
Instead of recursion, we have 'typedef' for clarity.


PEDNING BUGS:
=============

* FIX on keyF that creates key to table cycles in the types, needs to consider environment due to bouned quantification.

* MISSING SUBTYPING RULE:

  X <: A in Gamma
-------------------
 Gamma |- X <: A
 FIXME: subtyping needs typing environment because of this. (equals does not but uses syntactic equality)
 FIXME: detecting cycles on subtyping is also more complex due to different bounds on the environment.
 	How to represent this?

// needs: getBound( ID, DEPTH ) // to account for De Bruijn indexes.

// tests:
< X<:int, Y<:int >
	subtype X <: Y

< X<:int, Y<:int >
	not equals X == Y
// ...

* FIXME: missing bounds on type definitions.
// test:
typedef N[A, B <: int] = N[int,int]

* grammar is messy, but defining operator precendence in jison is not working?!

TODO:
=====

* undecidable exists X <: A || forall Y <: B, iff A <: B, we must restrict bound to be EMPTY |- A type, no variables.

* Protocol Well-Formedness:
	- isProtocol( type ) true if type contains a protocol, false if non-protocol type
	- check that each RelyType and GuaranteeType refer the same set of locations (location set invariant)
	- (+) ensure distinctness in alternative triggers (distinct alternative)
	- abstractions:
		+ same level abstraction must only refer X <: P where isProtocol(P)
		+ or X must also be at the guarantee type unabstracted?

* Protocol Conformance:

- define error constants/enum instead of having constants spread out through the code.

STYLE:
======

- use 'const' keyword for constants. Note that some browsers may not support this. However, our target is Google Chrome which does support 'const'. See: http://kangax.github.io/compat-table/es6/


FIXME --- GRAMMAR:
==================

* FIXME: is it possible to remove unnecessary keywords (such as 'subtype' and 'equals')?

 not A <: A // subtype test
 not A == A // equality test
 	--> PROBLEM: ambiguity in the grammar!
 
 share A as B, C, D, E;
 share D as D, D;
 	--> PROBLEM: implicit associativity.

Extra Credits:
==============
- Types and Programming Languages, Chapter 6 (for De Bruijn stuff).
- Subtyping Recursive Types, for recursion checks.




			// FIXME old equality of definitions --- is this no longer needed??
			/*
			case types.DefinitionType:{
				if( t1.definition() !== t2.definition() )
					return false;
				
				var t1s = t1.args();
				var t2s = t2.args();
				if( t1s.length !== t2s.length )
					return false;
				for( var i=0;i<t1s.length;++i )
					if( !equalsAux( t1s[i], t2s[i], trail ) )
						return false;
				return true;
			} */