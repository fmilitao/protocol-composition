Protocol Conformance Checker
============================

Grammar is limited to only check 'equals', 'subtype' and 'share' (and substitution).
Instead of recursion, we have 'typedef' for clarity.

TODO/PROBLEMS/BUGS:
===================

* Check if case is really undecidable. Add check to forbid undecidable case, if that is the case. It may be possible that the example is ill-constructed and therefore fails to catch this error. Thus, you may need to build a better counter-example that exercises the problem.
	The case is undecidable at least on protocol conformance. If we have:
	P[A] = rw p A => forall X <: A.( rw p X ; P[X] )
	then the typing environment will grow without end, making the use of subsumption on conformance impossible and therefore
we will never be able to close the proof.

	The simple solution if to enforce that:
	EMPTY |- A type 	Gamma, X <: A |- B type
	-------------------------------------------
		Gamma |- forall X <: A.B

	(and same for exists)

	Likewise, our examples need something of the kind:

		( X <: A ) in Gamma
	 Gamma |- A <: B
	------------------- (i.e. transitivity on bounds?)
	 Gamma |- X <: B

	but this may be undecidable is we do not constrain the type in the bounded quantification type.

* undecidable exists X <: A || forall Y <: B, iff A <: B, we must restrict bound to be EMPTY |- A type, no variables.

* FIX on keyF that creates key to table cycles in the types, needs to consider environment due to bouned quantification.

* Protocol Well-Formedness:
	- isProtocol( type ) true if type contains a protocol, false if non-protocol type
	- check that each RelyType and GuaranteeType refer the same set of locations (location set invariant)
	- (+) ensure distinctness in alternative triggers (distinct alternative)
	- abstractions:
		+ same level abstraction must only refer X <: P where isProtocol(P)
		+ or X must also be at the guarantee type unabstracted?

* consider "superficial equality" (i.e. no need to unfold):
	case types.DefinitionType:
		if( t1.definition() !== t2.definition() )
			return false;
		
		var t1s = t1.args();
		var t2s = t2.args();
		if( t1s.length !== t2s.length )
			return false;
		for( var i=0;i<t1s.length;++i )
			if( !equalsAux( t1s[i], t2s[i], trail ) )
				return false;
		return true;
	}




- define error constants/enum instead of having constants spread out through the code.

- use 'const' keyword for constants. Note that some browsers may not support this. However, our target is Google Chrome which does support 'const'. See: http://kangax.github.io/compat-table/es6/



Extra Credits:
==============

- Types and Programming Languages, Chapter 6 (for De Bruijn stuff).
- Subtyping Recursive Types, for recursion checks.

